Title:    자랑스러운 우리회사의 숨은 일꾼 만들기
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   yongbin

## 저자

[@yongbin](http://twitter.com/yongbin) - aka 용사장 / Minivelo++ / 맞춤법 전문가

## 시작하며

첫눈이 내리고, 어김없이 캐롤이 울려퍼지면, 거리에는 삼삼오오 각자 소중한
사람들과 함께 즐거운 시간을 보내는 사람들로 북적거리는 연말이 찾아왔음을 느낄
수 있습니다. 하지만 모두가 즐거운 시간을 보내는 이 순간에도 원할한 서비스를
위해서 누군가는 어딘가에서 묵묵히 일을 해야만 합니다. 크리스마스 이브에
야근을 해야하는 그 누군가가 내가 되지 않기 위해서는 그 일을 맡길 다른 사람을
얼른 찾아야 합니다.

Gearman은 이런 우리의 고민을 해결해 줄수 있는 근사한 해결책중에
하나입니다. Gearman 은 내가 작성한 일꾼들을 불철주야 감시하며 언제든 내가
원하는 일을 처리할수 있는 환경을 제공해 줍니다. 일꾼은 항상 제가 시킨일을
묵묵히 할 뿐만 아니라 필요하면 언제든이 일꾼의 수를 늘리거나 줄일수
있습니다. 일꾼1과 일꾼2가 Job Queue 작업장에서 만나 비밀 사내 연애 끝에
결혼을 해 일꾼3을 출산하게 되어 육아휴직을 쥐야할 일도 없고, 임금인상이나
퇴직금을 요구하지도 않으며 노조를 결성해서 파업을 할 걱정도 없으므로 회사를
경영하는 입장에서는 더할나위 없이 좋은 대안입니다.

그리고 Gearman과 같은 Job Queue 방식의 구조를 차용할 경우 시간이 오래걸리는
작업에 대해 병목이 되는 지점에 추가적인 더 활당해서 그 일을 병렬로 처리해
작업의 처리 효율을 높힐수도 있고, 때로는 서비스1과 서비스2에서 반복적으로
사용하는 공통 기능 X를 각각의 서비스마다 중복해서 구현하지 않고 외부에
둠으로써 구조를 개선할 수도있습니다.

## Gearman 소개

Gearman 은 memcached, MogileFS 으로 유명한 Danga Interactive에서 개발한 제품중에
하나로 유명한 펄 해커인 Brad Fitzpatrick 씨가 제작했습니다. 초창기 Gearman 은
순수하게 펄로 작성되었고 클라이언트 라이브러리도 주로 펄만
고려되었습니다. 하지만 이후 Eric Day 씨가 Gearman을 C로 재작성하고 타 언어에
대한 클라이언트 라이브러리 지원등을 강화하면서 지금의 Gearman은 언어중립적이고
포괄적인 분산 프로세스 플랫폼으로 발전했습니다. 현재 Gearman의 워커로
등록시킬수 있는 언어는 C, Perl, Python, PHP, Java, Go와, 그리고 MySQL의
UDF(User Defined Function)이 있습니다.따라서 Gearman을 사용하면 Java로 작성한
워커를 Perl로 작성된 응용프로그램에서 사용하거나 그 반대의 상황을 만드는것이
아주 쉬워집니다.

## Gearman 구성요소

Gearman 을 이해하기 위해서는 먼저 Gearman 을 구성하고 있는 요소들의 특징과
역활을 이해할 필요가 있습니다.

### Gearman Server
  - [Gearman::Server](http://search.cpan.org/~dormando/Gearman-Server-1.11/lib/Gearman/Server.pm)(perl), [gearmand](http://gearman.org/)(c)
  - Client 로부터 전달받은 작업을 적절한 워커로 분배하는 역할을 합니다.
  - 초기 Gearman 은 작업을 따로 저장하지 않고 메모리에서 처리했지만 현재는
    다양한 영속 저장방법을 지원하고 있습니다. ( libmemcached, libdrizzle,
    SQLite, Mysql, Postgres, tokyocabinet, Redis , Mongodb )
  - 멀티서버를 지원합니다.
### Gearman Worker
  - [Gearman::Worker](http://search.cpan.org/~dormando/Gearman-1.11/lib/Gearman/Worker.pm)(perl), [Gearman::XS::Worker](http://search.cpan.org/~dschoen/Gearman-XS-0.12/lib/Gearman/XS/Worker.pm)(libgearmand)
  - 실제 우리가 원하는 작업을 수행하는 프로세스 입니다.
  - 위에 언급한 것 처럼 다양한 언어로 작성될 수 있습니다.
### Gearman Client
    - [Gearman::Client](http://search.cpan.org/~dormando/Gearman-1.11/lib/Gearman/Client.pm)(perl), [Gearman::XS::Xlient](http://search.cpan.org/~dschoen/Gearman-XS-0.12/lib/Gearman/XS/Client.pm])(libgearmand)
    - Worker 에게 작업을 시키는 프로세스입니다.
    - 마찬가지로 다양한 언어로 작성될 수 있습니다.

## Gearman 감 잡기

Gearman의 동작방식을 이해하기 위한 간단한 예제를 살펴보겠습니다.

### Gearman Server 및 환경 구성하기

먼저 CPAN을 통해 간단하게 Gearman::Server 를 설치하고 기동합니다. 현재
활발하게 개발되고, 다양한 기능을 갖추고 있는것은 C로 구현된 gearmand 이지만
지금은 간단한 테스트를 할 예정이기 떄문에 Pure Perl Gearman::Server를
사용하기로 합니다.

    #!bash
    $ cpanm -n Gearman::Server Gearman::Worker Gearman::Client
    $ gearmand

  - Gearman::Server를 설치하고 나면 gearmand 라는 CLI 도구가 설치됩니다.
  - gearmand 를 실행하면 127.0.0.1에 7003번 포트로 Gearman Server가
      구동됩니다.

### Gearman Client의 작성

다음으로 워커를 작성하는 대신, 워커를 이용하는 Client 코드를 먼저 작성해
보도록 하겠습니다. 이렇게 순서를 바꿔서 진행하는 이유는 조금더 Gearman의
동작방식을 잘 이해하기 위해서 입니다.

    #!perl
    #!/usr/bin/env perl
    use Gearman::Client;
    use Storable qw( freeze );
    my $client = Gearman::Client->new;
    $client->job_servers('127.0.0.1:7003');

    my $tasks  = $client->new_task_set;
    my $handle = $tasks->add_task(
        sum => freeze( [ 3, 5 ] ),
        {
            on_complete => sub { print ${ $_[0] }, "\n" }
        }
    );
    $tasks->wait;

  - `sum` 이라는 워커에게 3과 5 인자를 전달하고 작업이 끝나면 처리 결과를
    화면에 출력하는 간단한 Client 코드입니다.
  - Gearman은 언어중립적이고 perl 과 무관하므로 Client 와 Worker사이에 인자를
    전달하기 위해서는 Stroable 이나 JSON과같은 마샬링처리가 필요합니다.
  - 이 코드를 실행하면 프로세스가 종료되지 않고 계속 대기하는것을 볼 수
    있습니다. 그 이유는 현재 Client가 처리 요청한 `sum` 워커가 존재하지 않기
    떄문에 적절한 워커가 생성될때까지 작업요청이 대기하게 됩니다.

### Gearman Worker의 작성

자 이제 `sum`이라는 일을 처리해줄 Worker를 만들어봅시다.

    #!perl
    #!/usr/bin/env perl
    use Gearman::Worker;
    use Storable qw( thaw );
    use List::Util qw(sum);

    my $worker = Gearman::Worker->new;
    $worker->job_servers('127.0.0.1:7003');
    $worker->register_function( sum => sub { sum @{ thaw( $_[0]->arg ) } } );
    $worker->work while 1;

  - Worker를 만들기 위해서는 Gearman::Worker 객체를 사용합니다.
  - 먼저 Worker가 등록될 등록될 적절한 Gearman Server를 지정합니다.
  - 그리고 등록할 함수를  Worker를 register_function를 이용해 등록하면 됩니다.
  - 이 코드에서는 sum 이라는 Worker는 List::Util에 있는 sum 함수를 제공하도록
    작성되어있습니다.
  - 위에서 설명한 것 처럼 Client 에서 인자를 Storable로 시리얼라이즈 해주었기
    때문에 Worker쪽에서도 마찬가지로 Storable의 thaw 함수를 통해 적절히
    언마샬링 하고 있습니다.
  - 이 코드를 실행시키면 거의 동시에 앞서서 실행했던 Client 쪽 프로세스가
    8이라는 결과를 내고 종료합니다. 왜냐하면 이 코드가 실행되는 순간 Job
    Server에는 `sum` 이라는 Worker가 등록되고 기존에 대기중이었던 작업이
    할당되고 처리되면서 Client 요청이 성공적으로 끝나기 때문입니다.
  - 이 워커코드를 한대의 장비에서 여러개를 띄울수도 있고, 심지어는
    분리되어있는 다른 장비에 나눠서 띄울수 있습니다. 어떤방식으로든 Worker를
    Job Server에 등록하기만 하면 그 다음부터 Client 에서는 Worker가 어디에
    어떻게 떠있는지 알 필요 없이 단순하게 요청하고 결과를 받으면 되고 작업의
    분배는 Job Server가 알아서 처리합니다.

## Gearman 실전

마지막으로 개인적으로 Gearman을 활용해 문제를 해결했던 상황을 간단하게
소개하고 오늘의 기사를 마무리하려고 합니다.

당시 1만개 정도의 웹페이지를 긁어온 뒤 필요한 자료를 추출하고 저장하는 작업이
있었습니다. 먼저 그 작업을 평범한 스크립트로 작성해서 실행시켜 본 결과 주로
로컬의 CPU와 메모리를 소모하는 자료의 추출 및 저장 프로세스보다 외부의 네트웍
자원을 소모하고 대역폭의 영향을 받는 웹페이지 추출작업이 대부분의 시간을
소모하는 병목지점임을 알게되었습니다.

이 프로세스의 속도를 개선하기 위해서 Gearman을 사용하기로 결정하고 다음과
같이 진행했습니다.

 - 먼저 기존에 작성했던 스크립트에서 혼재되어있는 코드를 각각의 작업영역별로
   함수단위로 정리하고 예전과 동일하게 동작하도록 수정했습니다.( 그 결과
   list_fetch, detail_fetch, store_page, parse_page 4개의 함수가
   만들어졌습니다 )
 - 각각의 함수들을 별도의 파일로 분리하고 Gearman::XS::Worker를 사용해 워커로
   등록했습니다.
 - 앞서 분석한 결과에 따라 주요 병목지점인 list_fetch 워커를 2개, detail_fetch
   워커를 6개 실행시키고 나머지 store_page, parse_page 워커는 하나씩만
   실행했습니다.
 - 만약 작업이 순차적으로 진행될 필요가 있는 경우, 즉 예를들어  list_fetch 한
   페이지를 통해 복수 페이지에 대한 detail_fetch 요청이 생성되고 그 결과에
   대해 parse_page와 store_page 요청이 생기는 경우에는 Gearman Worker 코드내에
   Gearman Client 코드를 삽입해 작업이 연쇄적으로 일어날 수 있도록
   조정했습니다.
 - C로 구현된 gearmand 를 컴파일해서 설치하고 작업의 저장은 로컬 SQLite를
   사용했으며 Perl Worker와 Client는 Gearman::XS::Client,
   Gearman::XS::Worker를 사용해서 작성했습니다.
 - 결과적으로 병목지점이 되던 네트웍 사용부분이 해소되면서 전체적인 실행시간에
   70% 정도의 개선이 있었습니다.

당시 사용했던 코드는 github에 올려두었으니 참고하시기 바랍니다.

<https://github.com/yongbin/gearman-fetch-ralphlauren>

## 맺으며

처음 Gearman을 접한다면 Server와 Worker, Client 가 분리되어있는 구조가 조금은
복잡하고 불필요하게 느껴질 수도있지만 단순하게 매번 반복접으로 실행되는 어떤
프로세스를 재사용 될수 있도록 구조화 시키는데 있어서 Gearman의 처리방식은
합리적이고 이점이 많습니다. 만약 아직도 단순하고 반복적인 업무를 매번
일일이 실행시키며 귀중한 시간을 낭비하고 있다면 올 겨울 Gearman과 그의 충실하고
믿음직 스러운 일꾼들에게 그 일을 맡겨보는건 어떨까요?

## 참고자료

 - [Gearman.org](http://gearman.org/)
   Eric Day의 C구현 Gearman 홈페이지, 각종 문서와 최신 자료가 풍부합니다.

 - [Gearman을 사용하여 PHP 애플리케이션의 워크로드 분배하기](http://www.ibm.com/developerworks/kr/library/os-php-gearman/)
   IBMdW 에 기재된 gearman - php 활용기사, perl gearman 자료는 아니지만
   Gearman을 이해하는데 도움이 되는 한글기사입니다.

 - [Evolution of SoundCloud’s Architecture](http://backstage.soundcloud.com/2012/08/evolution-of-soundclouds-architecture/)
   Gearman 을 직접다루지는 않지만 Job Queue 기반의 서브시스템을 활용해
   웹서비스의 기능을 확장하는 과정을 잘 설명하고 있습니다.
