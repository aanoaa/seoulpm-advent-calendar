Title:    미정
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   luzluna


저자
-----

[@luzluna][twitter-luzluna] - 
Seoul.pm과 #perl-kr의 육아 전문 컨설턴트, 사회적 기업을 꿈꾸는 커피 매니아이자 백수,
제주와 서울을 오가며 몽거스 활동을 하고 있다.


시작하며
--------

비동기 웹서버의 유행들을 따라
펄에도 비동기 웹서비스를 제공할만한 좋은 방법들이 몇 가지 생겼습니다.
그 중 [Tatsumaki][cpan-tatsumaki]는 [Tatsuhiko Miyagawa][cpan-author-miyagawa]씨께서
Python의 [Tornado][python-tornado]를 펄 버전으로 새로 구현한 프레임워크입니다.

비동기 웹서버에 대해 부정적으로 생각하지만([Larry Wall][wiki-larry-wall]의 표현을 빌어 표현하자면 *"Not For Human"*),
웹 상에서 채팅이나 메신저같은 Long Polling 서비스를 구현하려면 마땅한 다른 방법도 없으니...
필요하면 배워야겠죠. ㅜ.ㅠ



예제를 봅시다
-------------

Tatsumaki 소스를 다운받으면 `eg` 디렉터리 아래에 [간단한 채팅 서버 예제][cpan-tatsumaki]가 있습니다.
먼저, `main` 코드입니다.

    #!perl
    package main;
    use File::Basename;
    
    my $chat_re = '[\w\.\-]+';
    my $app = Tatsumaki::Application->new([
        "/chat/($chat_re)/poll" => 'ChatPollHandler',
        "/chat/($chat_re)/mxhrpoll" => 'ChatMultipartPollHandler',
        "/chat/($chat_re)/post" => 'ChatPostHandler',
        "/chat/($chat_re)" => 'ChatRoomHandler',
    ]);
    
    $app->template_path(dirname(__FILE__) . "/templates");
    $app->static_path(dirname(__FILE__) . "/static");
    
    return $app->psgi_app;

Tatsumaki::Application를 생성하면서 처리할 URL 패턴과 각 패턴에 대한 핸들러를 추가해줍니다.
그런 다음 템플릿 경로(`template_path`) 설정도 해주고 정적 파일(`static_file`)을 처리하기 위한 설정도 추가해주네요.
여기까진 간단하죠?

그럼 `ChatRoomHandler`를 한번 보겠습니다.

    #!perl
    package ChatRoomHandler;
    use base qw(Tatsumaki::Handler);
    
    sub get {
        my($self, $channel) = @_;
        $self->render('chat.html');
    }

그냥 chat.html 템플릿을 랜더링하네요.
이번엔 `ChatPostHandler`입니다.

    #!perl
    package ChatPostHandler;
    use base qw(Tatsumaki::Handler);
    use HTML::Entities;
    use Encode;
    
    sub post {
        my($self, $channel) = @_;
    
        my $v = $self->request->parameters;
        my $html = $self->format_message($v->{text});
        my $mq = Tatsumaki::MessageQueue->instance($channel);
        $mq->publish({
            type => "message", html => $html, ident => $v->{ident},
            avatar => $v->{avatar}, name => $v->{name},
            address => $self->request->address,
            time => scalar Time::HiRes::gettimeofday,
        });
        $self->write({ success => 1 });
    }
    
    sub format_message {
        my($self, $text) = @_;
        $text =~ s{ (https?://\S+) | ([&<>"']+) }
                  { $1 ? do { my $url = HTML::Entities::encode($1); qq(<a target="_blank" href="$url">$url</a>) } :
                    $2 ? HTML::Entities::encode($2) : '' }egx;
        $text;
    }

핵심적인 코드는 아래와 같이 채널 이름에 맞는 Tatsumaki::MessageQueue를 만드는 코드와

    #!perl
    $mq = Tatsumaki::MessageQueue->instance($channel);`
    
아래와 같이 메시지를 Queue에 쏘는 두 줄이 끝입니다.

    #!perl
    $mq->publish({
        type => "message", html => $html, ident => $v->{ident},
        avatar => $v->{avatar}, name => $v->{name},
        address => $self->request->address,
        time => scalar Time::HiRes::gettimeofday,
    });

이번엔 `ChatPollHander`를 봅시다.

    #!perl
    package ChatPollHandler;
    use base qw(Tatsumaki::Handler);
    __PACKAGE__->asynchronous(1);
    
    use Tatsumaki::MessageQueue;
    
    sub get {
        my($self, $channel) = @_;
        my $mq = Tatsumaki::MessageQueue->instance($channel);
        my $client_id = $self->request->param('client_id')
            or Tatsumaki::Error::HTTP->throw(500, "'client_id' needed");
        $client_id = rand(1) if $client_id eq 'dummy'; # for benchmarking stuff
        $mq->poll_once($client_id, sub { $self->on_new_event(@_) });
    }
    
    sub on_new_event {
        my($self, @events) = @_;
        $self->write(\@events);
        $self->finish;
    }

방금 본 `post` 함수와 비슷합니다.
Tatsumaki::MessageQueue 인스턴스를 하나 만들고 `$mq->poll_once`로 대기합니다. 
이벤트가 도착하면 이벤트를 보내면(`$self->write(\@events)`) 끝입니다.
`ChatMultipartPollHandler`는 어떨까요?

    #!perl
    package ChatMultipartPollHandler;
    use base qw(Tatsumaki::Handler);
    __PACKAGE__->asynchronous(1);
    
    sub get {
        my($self, $channel) = @_;
    
        my $client_id = $self->request->param('client_id') || rand(1);
    
        $self->multipart_xhr_push(1);
    
        my $mq = Tatsumaki::MessageQueue->instance($channel);
        $mq->poll($client_id, sub {
            my @events = @_;
            for my $event (@events) {
                $self->stream_write($event);
            }
        });
    }

거의 비슷한데 멀티파트니까
`multipart_xhr_push`를 한줄 넣어서 멀티파트 헤더를 추가해주고 연결을 끊지 않고 계속 poll하면서
`stream_write`로 event를 전송합니다.

    #!bash
    $ plackup -s Twiggy app.psgi

[plackup][plackup]을 통해서 [Twiggy][twiggy]로 띄우면... 채팅 잘 되네요~


보너스!
-------

채팅만 하려니까 뭔가 심심해서 재미있는걸 해볼 수 있게 canvas를 추가해봤습니다.
chat.html에다가

    #!html
    <canvas id="c" width="200" height="100" style="border:1px solid"></canvas>

이렇게 한줄 추가하고...

    #!html
    <script>
    function draw_dot(x,y) {
        var canvas = document.getElementById('c');
        var ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(x,y,5,0,Math.PI*2,true);
        ctx.fillStyle = '#5555AA';
        ctx.fill();
        ctx.stroke();
    }

    $(function(){
        $('#c').mouseup(function(e) {
            var canoffset = $('#c').offset();
            var x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft - Math.floor(canoffset.left);
            var y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop - Math.floor(canoffset.top) + 1;
            
            draw_dot(x,y);
            
            $.ajax({
                url: "/chat/<%= $channel %>/post",
                data: { type: 'game', x: x, y: y, text:'g' },
                type: 'post',
                dataType: 'json',
                success: function(r) { }
            });

        });

        var onGameEvent = function(e) {
            draw_dot(e.x, e.y);
        }
        $.ev.handlers.game = onGameEvent;
    });
    </script>
    
이렇게 스크립트를 좀 추가해놓으면
캔버스에 클릭으로 점을 찍으면 상대편에게도 점이 찍히는게 보이죠?

로직을 좀 구현해넣으면 간단한
게임도 만들 수 있을 것 같고 그림을 공유하는 것도 될 것 같네요.
이렇게 해놓고보니 타입이 game인 경우 처리하는 서버 코드가 좀 들어가야겠네요.
대충 game타입이 들어올경우만 처리하도록 살짝 수정 했습니다.

    #!perl
    package ChatPostHandler;
    use base qw(Tatsumaki::Handler);
    use HTML::Entities;
    use Encode;
    
    sub post {
        my($self, $channel) = @_;
    
        for ( keys %{$self->request->parameters} ) {
            $self->request->parameters->{$_} = decode('utf8', $self->request->parameters->{$_});
        }
        my $v = $self->request->parameters;
        my $html = $self->format_message($v->{text});
        my $mq = TatsumakiZeroMQ->instance($channel);
        if (defined $v->{type} && $v->{type} eq 'game' ) {
            $mq->publish({
                type => "game", html => $html,
                x => $v->{x}, y => $v->{y},
                ident => $v->{ident},
                avatar => $v->{avatar}, name => $v->{name},
                address => $self->request->address,
                time => scalar Time::HiRes::gettimeofday,
            });
        }
        else {
            $mq->publish({
                type => "message", html => $html, ident => $v->{ident},
                avatar => $v->{avatar}, name => $v->{name},
                address => $self->request->address,
                time => scalar Time::HiRes::gettimeofday,
            });
        }
        $self->write({ success => 1 });
    }


참고 문서
--------

- [Tatsumaki SlideShare](http://www.slideshare.net/miyagawa/tatsumaki)
- [PSGI/Plack](http://plackperl.org/)
- 



[twitter-luzluna]: http://twitter.com/luzluna
[cpan-tatsumaki]: http://search.cpan.org/perldoc?Tatsumaki
[plackup]: http://search.cpan.org/perldoc?plackup
[twiggy]: http://search.cpan.org/perldoc?Twiggy
[python-tornado]: http://www.tornadoweb.org/
[cpan-author-miyagawa]: http://search.cpan.org/~miyagawa/
[wiki-larry-wall]: http://en.wikipedia.org/wiki/Larry_Wall
